<infinite-scroll
  data-next="{{ next_page }}"
  data-page-size="{{ page_size }}"
  data-end-text="{{ end_text }}">
  {% if page_size > 1 %}
    <div class="loadingBox">
      <span id="loading_1" class="loadingScroll">&nbsp</span>
      <span id="loading_2" class="loadingScroll">&nbsp</span>
      <span id="loading_3" class="loadingScroll">&nbsp</span>
      <span id="loading_4" class="loadingScroll">&nbsp</span>
      <span id="loading_5" class="loadingScroll">&nbsp</span>
      <span id="loading_6" class="loadingScroll">&nbsp</span>
      <span id="loading_7" class="loadingScroll">&nbsp</span>
      <span id="loading_8" class="loadingScroll">&nbsp</span>
    </div>
  {% endif %}
</infinite-scroll>
<style>
  infinite-scroll {
    position: relative;
    width: 100%;
    font-weight: 600;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.5s ease;
  }
  .loadingBox {
    position: relative;
    width: 234px;
    height: 28px;
    margin: auto;
  }
  .loadingScroll {
    position: absolute;
    top: 0;
    background-color: rgb(0, 0, 0);
    width: 28px;
    height: 28px;
    animation-name: loading_animation;
    -o-animation-name: loading_animation;
    -ms-animation-name: loading_animation;
    -webkit-animation-name: loading_animation;
    -moz-animation-name: loading_animation;
    animation-duration: 1.5s;
    -o-animation-duration: 1.5s;
    -ms-animation-duration: 1.5s;
    -webkit-animation-duration: 1.5s;
    -moz-animation-duration: 1.5s;
    animation-iteration-count: infinite;
    -o-animation-iteration-count: infinite;
    -ms-animation-iteration-count: infinite;
    -webkit-animation-iteration-count: infinite;
    -moz-animation-iteration-count: infinite;
    animation-direction: normal;
    -o-animation-direction: normal;
    -ms-animation-direction: normal;
    -webkit-animation-direction: normal;
    -moz-animation-direction: normal;
    transform: scale(0.3);
    -o-transform: scale(0.3);
    -ms-transform: scale(0.3);
    -webkit-transform: scale(0.3);
    -moz-transform: scale(0.3);
  }
  #loading_1 {
    left: 0;
    animation-delay: 0.6s;
    -o-animation-delay: 0.6s;
    -ms-animation-delay: 0.6s;
    -webkit-animation-delay: 0.6s;
    -moz-animation-delay: 0.6s;
  }
  #loading_2 {
    left: 29px;
    animation-delay: 0.75s;
    -o-animation-delay: 0.75s;
    -ms-animation-delay: 0.75s;
    -webkit-animation-delay: 0.75s;
    -moz-animation-delay: 0.75s;
  }
  #loading_3 {
    left: 58px;
    animation-delay: 0.9s;
    -o-animation-delay: 0.9s;
    -ms-animation-delay: 0.9s;
    -webkit-animation-delay: 0.9s;
    -moz-animation-delay: 0.9s;
  }
  #loading_4 {
    left: 88px;
    animation-delay: 1.05s;
    -o-animation-delay: 1.05s;
    -ms-animation-delay: 1.05s;
    -webkit-animation-delay: 1.05s;
    -moz-animation-delay: 1.05s;
  }
  #loading_5 {
    left: 117px;
    animation-delay: 1.2s;
    -o-animation-delay: 1.2s;
    -ms-animation-delay: 1.2s;
    -webkit-animation-delay: 1.2s;
    -moz-animation-delay: 1.2s;
  }
  #loading_6 {
    left: 146px;
    animation-delay: 1.35s;
    -o-animation-delay: 1.35s;
    -ms-animation-delay: 1.35s;
    -webkit-animation-delay: 1.35s;
    -moz-animation-delay: 1.35s;
  }
  #loading_7 {
    left: 175px;
    animation-delay: 1.5s;
    -o-animation-delay: 1.5s;
    -ms-animation-delay: 1.5s;
    -webkit-animation-delay: 1.5s;
    -moz-animation-delay: 1.5s;
  }
  #loading_8 {
    left: 205px;
    animation-delay: 1.64s;
    -o-animation-delay: 1.64s;
    -ms-animation-delay: 1.64s;
    -webkit-animation-delay: 1.64s;
    -moz-animation-delay: 1.64s;
  }

  /* Pristege */
  [class^="pagination"],
  [class^="Pagination"],
  .pagination {
    display: none !important;
  }

  .js .features--show-element-staggering .ProductList--grid div.ProductItem {
    visibility: visible;
  }

  .js .product-card[reveal-on-scroll="true"] {
    opacity: 1;
  }

  /* Force images to be visible for infinite scroll loaded content */
  .image-wrap img:not([role=presentation]) {
    opacity: 1 !important;
  }
  .image-wrap .animate-me {
    opacity: 1 !important;
  }
  .image-wrap svg {
    opacity: 1 !important;
  }

  @keyframes loading_animation {
    0% {
      transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-o-keyframes loading_animation {
    0% {
      -o-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -o-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-ms-keyframes loading_animation {
    0% {
      -ms-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -ms-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-webkit-keyframes loading_animation {
    0% {
      -webkit-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -webkit-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-moz-keyframes loading_animation {
    0% {
      -moz-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -moz-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
</style>
<script>
  class InfiniteScroll extends HTMLElement {
  constructor() {
    super();
    this.initGrid();
    this.init();
    this.page = 1;
    this._ended = false;
    this._loading = false;
    this.isRestoring = false;
    this.totalPages = parseInt(this.dataset.pageSize || '0', 10);
    this.cameFromProduct = /\/products\//.test(document.referrer || '');
    // Fallback for next page base if not provided
    if (!this.dataset.next) {
      try {
        const current = new URL(window.location.href);
        current.searchParams.delete('page');
        const base = current.pathname + (current.search ? current.search : '');
        this.dataset.next = base;
      } catch(_) {}
    }
    // Attempt to restore state from URL or session storage
    setTimeout(() => {
      this.restoreState();
      this.attachProductClickSaver();
    }, 0);
  }
  
  initGrid() {
    // Prefer scoping to the collection content container first
    const gridOptions = [
      "#CollectionAjaxContent .collection-grid__wrapper .grid",
      "#CollectionAjaxContent .grid--uniform",
      ".collection-grid__wrapper .grid",
      ".grid--uniform",
      "#product-grid",
      "#main-collection-product-grid",
      ".product-list",
      ".ProductListWrapper"
    ];
    for (let gridName of gridOptions) {
      const grid = document.querySelector(gridName);
      if (grid) {
        this.gridName = gridName;
        this.gridContainer = grid;
        break;
      }
    }
    // Fallback to the broadest grid if nothing matched
    if (!this.gridContainer) {
      this.gridName = ".grid--uniform";
      this.gridContainer = document.querySelector(this.gridName) || document.querySelector(".grid");
    }
  }
  
  init() {
    this.observer = new IntersectionObserver(this.revealItem.bind(this), {
      root: null,
      threshold: 0.05,
    });
    this.observer.observe(this);
  }
  endInfiniteScroll() {
    if (this._ended) return;
    this._ended = true;
    try { this.observer && this.observer.unobserve(this); } catch(_) {}
    try {
      const loader = this.querySelector('.loadingBox');
      if (loader) {
        loader.style.display = 'none';
        loader.innerText = '';
      }
    } catch(_) {}
  }
  
  fetchNextPage(nextPage) {
    if (this._ended || this._loading) return;
    if (!this.dataset.next) {
      console.warn("No next page URL provided.");
      this.endInfiniteScroll();
      return;
    }
    try {
      const loader = this.querySelector('.loadingBox');
      if (loader) loader.style.display = '';
    } catch(_) {}
    this._loading = true;
    const i = new URL(this.dataset.next, window.location.origin);
    i.searchParams.set("page", nextPage);
    const r = i.href;
    console.log("Fetching next page:", r, "next:", this.dataset.next);
    fetch(r, { method: "GET", headers: { "Accept": "text/html" }, credentials: "same-origin" })
      .then((resp) => resp.text())
      .then((html) => {
        const t = new DOMParser().parseFromString(html, "text/html");
        // Scope to collection content if present on the fetched page
        const scope = t.querySelector("#CollectionAjaxContent") || t;
        let grid = scope.querySelector(this.gridName)
          || scope.querySelector(".collection-grid__wrapper .grid")
          || scope.querySelector(".grid--uniform")
          || scope.querySelector(".grid");
        var fetchedHasItems = false;
        try { fetchedHasItems = !!(grid && grid.innerHTML && grid.innerHTML.replace(/\s+/g, '').length > 0); } catch(_) {}
        if (grid) {
          // If our container was not found earlier, re-detect on current page
          if (!this.gridContainer) {
            this.gridContainer = document.querySelector(this.gridName)
              || document.querySelector("#CollectionAjaxContent .collection-grid__wrapper .grid")
              || document.querySelector("#CollectionAjaxContent .grid--uniform")
              || document.querySelector(".collection-grid__wrapper .grid")
              || document.querySelector(".grid--uniform")
              || document.querySelector(".grid");
          }
          this.gridContainer.insertAdjacentHTML("beforeend", grid.innerHTML);
          console.log("Successfully loaded next page products");
          
          if (typeof AOS !== 'undefined') {
            AOS.refresh();
          }
          
          // Determine if there is a next page available
          const relNextEl = t.querySelector('link[rel="next"], a[rel="next"]');
          const hasRelNext = !!(relNextEl && relNextEl.getAttribute('href'));
          const hasMoreByTotal = this.totalPages > 0 ? (nextPage < this.totalPages) : null;
          const hasNext = hasRelNext || (hasMoreByTotal === true);

          // Advance page only after a successful append
          if (fetchedHasItems) {
            this.page = nextPage;
          }

          // If we just loaded last page or no items returned, end
          if (!hasNext || !fetchedHasItems) {
            this.endInfiniteScroll();
          }
        } else {
          console.warn("No grid found in fetched page. Tried:", this.gridName);
          // Try a deeper fallback within the entire fetched document
          const alt = t.querySelector(".grid--uniform") || t.querySelector(".collection-grid__wrapper .grid") || t.querySelector(".grid");
          if (alt) {
            this.gridContainer.insertAdjacentHTML("beforeend", alt.innerHTML);
            console.log("Found grid using broad fallback selector");
            if (typeof AOS !== 'undefined') {
              AOS.refresh();
            }
            const relNextEl = t.querySelector('link[rel="next"], a[rel="next"]');
            const hasRelNext = !!(relNextEl && relNextEl.getAttribute('href'));
            const hasMoreByTotal = this.totalPages > 0 ? (nextPage < this.totalPages) : null;
            const hasNext = hasRelNext || (hasMoreByTotal === true);
            const altHasItems = !!(alt && alt.innerHTML && alt.innerHTML.replace(/\s+/g, '').length > 0);
            if (altHasItems) {
              this.page = nextPage;
            }
            if (!hasNext || !altHasItems) {
              this.endInfiniteScroll();
            }
          } else {
            // No grid found in fetched page; try again on next intersection
          }
        }
        // Update URL to reflect current page so users can return to the same position
        try {
          this.updateURLPageParam(this.page);
          // Persist lightweight state in sessionStorage as well
          this.saveState();
        } catch (err) {
          console.warn("Failed to update URL/state:", err);
        }
        // Update URL/state only when not restoring
        if (!this.isRestoring) {
          try {
            this.updateURLPageParam(this.page);
            this.saveState();
          } catch (err) {
            console.warn("Failed to update URL/state:", err);
          }
        }
      })
      .catch((e) => {
        console.error("Error fetching next page:", e);
        // On error, avoid endless spinner
        this.endInfiniteScroll();
      })
      .finally(() => { this._loading = false; });
  }
  
  getNextPageUrl(htmlContent) {
    try {
      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlContent, "text/html");
      // Prefer rel=next if present
      const relNext = doc.querySelector('link[rel="next"], a[rel="next"]');
      if (relNext && relNext.getAttribute('href')) {
        return new URL(relNext.getAttribute('href'), window.location.origin).href;
      }
      // Then check our component marker
      const infiniteScrollElement = doc.querySelector("infinite-scroll");
      if (infiniteScrollElement && infiniteScrollElement.dataset.next) {
        return new URL(infiniteScrollElement.dataset.next, window.location.origin).href;
      }
      // Fallback: any pagination link that looks like next
      const nextCandidates = Array.from(doc.querySelectorAll('a[href*="page="]'));
      if (nextCandidates.length) {
        const currentPage = this.page;
        const nextLink = nextCandidates.find(a => {
          try {
            const u = new URL(a.getAttribute('href'), window.location.origin);
            const p = parseInt(u.searchParams.get('page') || '0', 10);
            return p > currentPage;
          } catch(_) { return false; }
        }) || nextCandidates[0];
        if (nextLink && nextLink.getAttribute('href')) {
          return new URL(nextLink.getAttribute('href'), window.location.origin).href;
        }
      }
    } catch(_) {}
    return null;
  }
  revealItem(e, t) {
    const [i] = e;
    if (!i.isIntersecting) return;
    if (this._ended || this._loading) return;
    const nextPage = this.page + 1;
    if (this.totalPages > 0 && nextPage > this.totalPages) { this.endInfiniteScroll(); return; }
    this.fetchNextPage(nextPage);
  }
  pauseObserver() {
    try { this.observer && this.observer.unobserve(this); } catch(_) {}
  }
  resumeObserver() {
    try { this.observer && this.observer.observe(this); } catch(_) {}
  }

  updateURLPageParam(page) {
    if (!this.cameFromProduct) return;
    const url = new URL(window.location.href);
    url.searchParams.set("page", String(page));
    window.history.replaceState({}, "", url.toString());
  }

  removePageParamFromUrl() {
    try {
      const url = new URL(window.location.href);
      url.searchParams.delete('page');
      window.history.replaceState({}, "", url.toString());
    } catch(_) {}
  }

  saveState(extra = {}) {
    try {
      const state = {
        page: this.page,
        scrollY: window.scrollY,
        next: this.dataset.next || null,
        grid: this.gridName || null,
        ...extra
      };
      sessionStorage.setItem(`infiniteScrollState:${location.pathname}`, JSON.stringify(state));
    } catch (_) {}
  }

  attachProductClickSaver() {
    if (!this.gridContainer) return;
    this.gridContainer.addEventListener("click", (evt) => {
      const link = evt.target.closest && evt.target.closest("a");
      if (link && /\/products\//.test(link.getAttribute("href") || "")) {
        // Save page and scroll before navigating to product
        this.saveState({ lastProductHref: link.getAttribute("href") });
      }
    }, true);
  }

  async restoreState() {
    // Try URL param first
    const url = new URL(window.location.href);
    const urlPage = parseInt(url.searchParams.get("page") || "1", 10);
    let targetPage = 1;

    // Try sessionStorage
    let saved = null;
    try {
      const raw = sessionStorage.getItem(`infiniteScrollState:${location.pathname}`);
      saved = raw ? JSON.parse(raw) : null;
    } catch (_) {}

    if (this.cameFromProduct) {
      // Only restore deep page when returning from a product page
      targetPage = isNaN(urlPage) ? 1 : Math.max(1, urlPage);
      if (saved && saved.page && saved.page > targetPage) targetPage = saved.page;
    } else {
      // Not coming from a product: start fresh and clear ?page
      this.removePageParamFromUrl();
      try { sessionStorage.removeItem(`infiniteScrollState:${location.pathname}`); } catch(_) {}
      targetPage = 1;
    }

    // Ensure we have a base next URL
    if (!this.dataset.next) {
      try {
        const current = new URL(window.location.href);
        current.searchParams.delete('page');
        const base = current.pathname + (current.search ? current.search : '');
        this.dataset.next = base;
      } catch(_) {}
    }

    // Preload pages up to targetPage (page 1 is already rendered)
    this.isRestoring = true;
    this.pauseObserver();
    if (targetPage > 1 && this.dataset.next) {
      for (let p = 2; p <= targetPage; p++) {
        this.page = p - 1; // ensure internal page aligns before fetchNextPage increments history
        await this.fetchNextPage(p);
      }
    }

    // Restore scroll position or last product in view only when returning from product
    if (this.cameFromProduct && saved) {
      if (saved.lastProductHref) {
        const selector = `a[href='${saved.lastProductHref}']`;
        const link = document.querySelector(selector);
        if (link) {
          const y = link.getBoundingClientRect().top + window.scrollY - 120;
          window.scrollTo({ top: Math.max(0, y), behavior: "auto" });
          this.isRestoring = false;
          this.resumeObserver();
          return;
        }
      }
      if (typeof saved.scrollY === "number") {
        window.scrollTo({ top: saved.scrollY, behavior: "auto" });
      }
    } else if (!this.cameFromProduct) {
      // Ensure top of page when not coming from a product
      try { window.scrollTo({ top: 0, behavior: "auto" }); } catch(_) {}
    }
    this.isRestoring = false;
    this.resumeObserver();
  }
  scrollToTopFx(e) {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
    e.currentTarget.style.display = "none";
  }
  }
  customElements.define("infinite-scroll", InfiniteScroll);
</script>